<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Tiny Train - Pick up goods and passengers</title>
  <style>
    html, body { height: 100%; }
    body { margin: 0; display: grid; place-items: center; background: #0d0f13; color: #d7e0ea; font: 14px/1.4 system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, "Noto Sans", sans-serif; }
    #wrap { display: flex; flex-direction: column; align-items: center; gap: .5rem; user-select: none }
    canvas { image-rendering: pixelated; background: #10131a; border: 1px solid #1d2330; box-shadow: 0 8px 24px rgba(0,0,0,.4); border-radius: 8px }
    .info { font-size: .85rem; opacity: .95; display: flex; gap: .5rem; align-items: center; max-width: 680px; text-align: center }
    .badge { background: #151b26; border: 1px solid #263047; padding: .12rem .45rem; border-radius: 999px; font-feature-settings: "tnum"; font-variant-numeric: tabular-nums; }
    button { background: #1b2333; color: #d7e0ea; border: 1px solid #2a3550; border-radius: 8px; padding: .35rem .6rem; cursor: pointer }
    button:active { transform: translateY(1px) }
    .hidden { display: none }
  </style>
</head>
<body>
  <div id="wrap">
    <canvas id="game" width="528" height="368" aria-label="Tiny Train yards game" role="img"></canvas>
    <div class="info">
      <span class="badge">Score: <span id="score">0</span></span>
      <span class="badge" id="status"></span>
    </div>
    <button id="restart" class="hidden" aria-label="Restart the game">Restart</button>
  </div>

  <script>
  (function(){
    // ===== World layout =====
    const YARD_COLS = 3; // 2x3 grid of yards
    const YARD_ROWS = 2;
    const COLS = 16;     // cells per yard (x)
    const ROWS = 12;     // cells per yard (y)
    const WALL = 1;      // wall thickness (cells) between yards
    const CELL = 20;     // px per cell

    const WORLD_COLS = YARD_COLS * COLS + (YARD_COLS - 1) * WALL;
    const WORLD_ROWS = YARD_ROWS * ROWS + (YARD_ROWS - 1) * WALL;

    // ===== Gameplay =====
    const SPEED_START = 150, SPEED_MIN = 90, SPEED_STEP = 3;
    const WRAP = false; // walls bound outer edges
    const BASE_SIZE = 8; // px square base for cars/engine (thickness grows this)
    // Konfigurierbare Wachstumsrate für Güter
    const THICKNESS_PER_GOOD = 3; // px Zuwachs pro aufgenommenem Gut
    // Anzahl der Passagiere und Güter gleichzeitig
    const PASSENGER_COUNT = 10;
    const GOODS_COUNT = 20;

    // === Station-Konstanten ===
    const STATION_VISIBLE_TIME = 15000;     // ms, 15 Sekunden sichtbar
    const STATION_HIDDEN_TIME = 5000;       // ms, 5 Sekunden unsichtbar
    const STATION_POINTS_GOOD = 10;        // Punkte pro Good
    const STATION_POINTS_PASSENGER = 5;    // Punkte pro Passenger

    const canvas = document.getElementById('game');
    canvas.width = WORLD_COLS * CELL; canvas.height = WORLD_ROWS * CELL;
    const ctx = canvas.getContext('2d');
    const scoreEl = document.getElementById('score');
    const statusEl = document.getElementById('status');
    const restartBtn = document.getElementById('restart');

    // Improved instruction baked in
    statusEl.textContent = 'Use arrows/WASD. Pick up Passengers (green) to grow longer and Goods (red) to grow thicker. There are 6 rail yards in a 2×3 grid. Yards are separated by walls but connected by bridges. Each bridge has a width limit — if your train thickness exceeds it when you enter, you crash. Hitting walls or yourself also ends the run.';

    let playing = false, dead = false, paused = false;
    let tickTimer = null, speed = SPEED_START;
    let dir = {x: 1, y: 0}, nextDir = {x: 1, y: 0};
    let train = [], score = 0;
    let passengers = []; // mehrere Passagiere
    let goods = [];      // mehrere Güter
    let thicknessPx = 0;  // grows by THICKNESS_PER_GOOD per goods, no cap

    // Brückenbreite (1, 2 oder 3 Zellen), wird alle 10s geändert
    let bridgeWidth = 3;
    let bridgeWidthTimer = null;

    // Walls + bridges
    const wallSet = new Set();          // key "x,y" for solid walls
    const bridgeMap = new Map();        // key "x,y" => {limitPx}

    // Gedroppte Items (letzte Cars)
    let droppedItems = [];

    // === Station-Variablen ===
    let station = null; // {x, y, w:2, h:2}
    let stationTimeout = null;
    let stationHiddenTimeout = null;

    function K(x,y){ return x+","+y; }

    // Brückenbreite zufällig wählen (1,2,3)
    function randomBridgeWidth() {
      return 1 + Math.floor(Math.random() * 3);
    }

    // Timer für Brückenbreiten starten (jetzt pro Brücke individuell)
    function startBridgeWidthTimer() {
      if (bridgeWidthTimer) clearInterval(bridgeWidthTimer);
      bridgeWidthTimer = setInterval(() => {
        // Für jede Brücke neue Breite setzen
        bridgeMap.forEach((meta, key) => {
          meta.width = randomBridgeWidth();
        });
        buildWorld();
        draw();
      }, 10000);
    }

    // Build yards and separating walls with bridges
    function buildWorld(){
      wallSet.clear(); bridgeMap.clear();
      // Vertikale Wände zwischen Yard-Spalten
      for (let yc=0; yc<YARD_ROWS; yc++){
        const y0 = yc * (ROWS + WALL);
        for (let xc=0; xc<YARD_COLS-1; xc++){
          const xWall = (xc+1)*COLS + xc*WALL; // global x index of wall column
          // Wand füllen
          for (let y=0; y<ROWS; y++) wallSet.add(K(xWall, y0 + y));
          // Brücke mittig, individuelle Breite
          const cy = y0 + Math.floor(ROWS/2);
          const limitPx = [10, 12, 14, 16][(yc*3+xc)%4]; // wie gehabt
          const width = bridgeMap.get(K(xWall, cy))?.width || randomBridgeWidth();
          const half = Math.floor(width/2);
          for (let dy=-half; dy<=half; dy++){
            if (Math.abs(dy) > Math.floor((width-1)/2)) continue; // für width=2 korrekt
            const yy = cy + dy;
            wallSet.delete(K(xWall, yy));
            bridgeMap.set(K(xWall, yy), {limitPx, width});
          }
        }
      }
      // Horizontale Wände zwischen Yard-Reihen
      for (let xc=0; xc<YARD_COLS; xc++){
        const x0 = xc * (COLS + WALL);
        for (let yc=0; yc<YARD_ROWS-1; yc++){
          const yWall = (yc+1)*ROWS + yc*WALL; // global y index of wall row
          for (let x=0; x<COLS; x++) wallSet.add(K(x0 + x, yWall));
          const cx = x0 + Math.floor(COLS/2);
          const limitPx = [9, 11, 13, 15][(xc*2+yc)%4];
          const width = bridgeMap.get(K(cx, yWall))?.width || randomBridgeWidth();
          const half = Math.floor(width/2);
          for (let dx=-half; dx<=half; dx++){
            if (Math.abs(dx) > Math.floor((width-1)/2)) continue;
            const xx = cx + dx;
            wallSet.delete(K(xx, yWall));
            bridgeMap.set(K(xx, yWall), {limitPx, width});
          }
        }
      }
      // Außenwände
      for (let x=0;x<WORLD_COLS;x++){ wallSet.add(K(x,-1)); wallSet.add(K(x,WORLD_ROWS)); }
      for (let y=0;y<WORLD_ROWS;y++){ wallSet.add(K(-1,y)); wallSet.add(K(WORLD_COLS,y)); }
    }

    function isWall(x,y){ return wallSet.has(K(x,y)); }
    function bridgeAt(x,y){ return bridgeMap.get(K(x,y)); }
    function isDroppedItem(x, y) {
      return droppedItems.some(item => item.x === x && item.y === y);
    }
    function isStation(x, y) {
      return station && x >= station.x && x < station.x + 2 && y >= station.y && y < station.y + 2;
    }

    function reset(){
      buildWorld();
      train = [
        {x: 2, y: Math.floor(ROWS/2)},
        {x: 1, y: Math.floor(ROWS/2)},
        {x: 0, y: Math.floor(ROWS/2)}
      ];
      dir = {x: 1, y: 0}; nextDir = dir;
      // Mehrere Passagiere und Güter platzieren
      passengers = [];
      goods = [];
      for (let i=0; i<PASSENGER_COUNT; i++) {
        let cell = randEmptyCell(passengers, goods);
        if (cell) passengers.push(cell);
      }
      for (let i=0; i<GOODS_COUNT; i++) {
        let cell = randEmptyCell(passengers, goods);
        if (cell) goods.push(cell);
      }
      score = 0; thicknessPx = 0; speed = SPEED_START; updateScore();
      dead = false; paused = false; playing = true;
      restartBtn.classList.add('hidden');
      if (tickTimer) clearInterval(tickTimer);
      tickTimer = setInterval(tick, speed);
      startBridgeWidthTimer();
      station = null;
      if (stationTimeout) clearTimeout(stationTimeout);
      if (stationHiddenTimeout) clearTimeout(stationHiddenTimeout);
      startStationCycle();
      draw();
    }

    function updateScore(){ scoreEl.textContent = score; }

    function randEmptyCell(passengersArr = passengers, goodsArr = goods){
      const used = new Set(train.map(s=>K(s.x,s.y)));
      passengersArr.forEach(p => used.add(K(p.x,p.y)));
      goodsArr.forEach(g => used.add(K(g.x,g.y)));
      let tries = 5000;
      while (tries--){
        const x = (Math.random()*WORLD_COLS)|0, y = (Math.random()*WORLD_ROWS)|0;
        if (used.has(K(x,y))) continue;
        if (isWall(x,y)) continue;            // no walls
        if (bridgeAt(x,y)) continue;          // avoid bridges for spawning
        return {x,y};
      }
      return null;
    }

    function tick(){
      if (!playing || paused || dead) return;
      dir = nextDir;
      let head = {x: train[0].x + dir.x, y: train[0].y + dir.y};

      // === Wrap-around für äußere Yards ===
      // Bestimme Yard-Index (Spalte/Zeile) für aktuelle und neue Position
      const oldYardCol = Math.floor(train[0].x / (COLS + WALL));
      const oldYardRow = Math.floor(train[0].y / (ROWS + WALL));
      let wrapped = false;
      // Links/rechts
      if (head.x < 0 && oldYardCol === 0) {
        // Links raus aus äußerem Yard -> rechts rein ins äußerste Yard
        head.x = WORLD_COLS - 1;
        wrapped = true;
      } else if (head.x >= WORLD_COLS && oldYardCol === YARD_COLS - 1) {
        // Rechts raus aus äußerem Yard -> links rein ins äußerste Yard
        head.x = 0;
        wrapped = true;
      }
      // Oben/unten
      if (head.y < 0 && oldYardRow === 0) {
        // Oben raus aus äußerem Yard -> unten rein ins äußerste Yard
        head.y = WORLD_ROWS - 1;
        wrapped = true;
      } else if (head.y >= WORLD_ROWS && oldYardRow === YARD_ROWS - 1) {
        // Unten raus aus äußerem Yard -> oben rein ins äußerste Yard
        head.y = 0;
        wrapped = true;
      }

      // Wenn nicht gewrappt und außerhalb, dann Game Over wie bisher
      if (!wrapped && (head.x<0 || head.x>=WORLD_COLS || head.y<0 || head.y>=WORLD_ROWS)){
        return gameOver('Hit the boundary!');
      }

      // --- Verbesserte Brückenkollision: prüfe alle betroffenen Zellen ---
      const carPixelWidth = BASE_SIZE + thicknessPx;
      let bridgeCrash = false;
      let bridgeDebug = [];
      // Prüfe, ob der Kopf auf eine Brückenzelle fährt
      if (bridgeAt(head.x, head.y)) {
        // Richtung bestimmen
        const perp = dir.x !== 0 ? {dx: 0, dy: 1} : {dx: 1, dy: 0};
        // Mittelpunktskoordinate des Kopfes in Pixeln
        const centerPx = {
          x: head.x * CELL + CELL/2,
          y: head.y * CELL + CELL/2
        };
        // Wie viele Zellen werden von der Breite belegt?
        const half = carPixelWidth / 2;
        // Start- und Endpunkt der Breite in Pixeln
        const startPx = (dir.x !== 0)
          ? centerPx.y - half
          : centerPx.x - half;
        const endPx = (dir.x !== 0)
          ? centerPx.y + half
          : centerPx.x + half;
        // Über alle betroffenen Zellen iterieren
        for (let p = startPx; p < endPx; p += CELL) {
          // Zellenindex bestimmen
          const cellIdx = Math.floor(p / CELL);
          const bx = dir.x !== 0 ? head.x : cellIdx;
          const by = dir.x !== 0 ? cellIdx : head.y;
          const br = bridgeAt(bx, by);
          bridgeDebug.push({bx, by, br});
          if (!br) { bridgeCrash = true; break; }
          if (carPixelWidth > br.width * CELL) { bridgeCrash = true; break; }
        }
        // Letzte Zelle prüfen (wegen Rundung)
        const lastCellIdx = Math.floor(endPx / CELL);
        const bx = dir.x !== 0 ? head.x : lastCellIdx;
        const by = dir.x !== 0 ? lastCellIdx : head.y;
        const br = bridgeAt(bx, by);
        bridgeDebug.push({bx, by, br});
        if (!br || carPixelWidth > br.width * CELL) bridgeCrash = true;
        // Debug-Ausgabe
        console.log('[BRIDGE COLLISION CHECK]', {
          head,
          carPixelWidth,
          BASE_SIZE,
          thicknessPx,
          CELL,
          direction: dir,
          bridgeDebug
        });
        if (bridgeCrash) {
          console.log('CRASH: Train too thick for this bridge or not fully on bridge!', {carPixelWidth, bridgeDebug});
          return gameOver('Train too thick for this bridge!');
        }
        // else: allowed to pass
      } else if (isWall(head.x, head.y)) {
        // Wandkollision
        // Aber: Wenn gerade gewrappt wurde, dann keine Kollision mit Außenwand
        if (!wrapped) {
          console.log('CRASH: Hit a wall!', head);
          return gameOver('Slammed into a wall!');
        }
      } else if (isDroppedItem(head.x, head.y)) {
        // Kollision mit gedropptem Item
        return gameOver('Crashed into dropped item!');
      }

      // Self collision
      for (let i=0;i<train.length;i++) if (train[i].x===head.x && train[i].y===head.y) return gameOver('Crashed into yourself!');
      train.unshift(head);
      // Pickup-Logik für mehrere Passagiere
      let pickedPassenger = passengers.findIndex(p => p.x === head.x && p.y === head.y);
      let pickedGoods = goods.findIndex(g => g.x === head.x && g.y === head.y);
      if (pickedPassenger !== -1){
        score++; updateScore();
        if (speed > SPEED_MIN){ clearInterval(tickTimer); speed = Math.max(SPEED_MIN, speed - SPEED_STEP); tickTimer = setInterval(tick, speed); }
        // Pickup ersetzen
        passengers[pickedPassenger] = randEmptyCell(passengers, goods);
        // Grow train length by not popping
      } else if (pickedGoods !== -1){
        score++; updateScore();
        thicknessPx += THICKNESS_PER_GOOD; // Konfigurierbare Zunahme
        goods[pickedGoods] = randEmptyCell(passengers, goods);
        train.pop(); // maintain length
      } else {
        train.pop();
      }
      // Station-Kollision prüfen
      let enteredStation = false;
      if (station) {
        for (let i = 0; i < train.length; i++) {
          if (isStation(train[i].x, train[i].y)) {
            enteredStation = true;
            break;
          }
        }
      }
      if (enteredStation) {
        // Zähle Passagier- und Güter-Cars (alle außer Engine)
        let goodsCount = 0, passengerCount = 0;
        for (let i = 1; i < train.length; i++) {
          if (i <= Math.floor(thicknessPx / THICKNESS_PER_GOOD)) {
            goodsCount++;
          } else {
            passengerCount++;
          }
        }
        score += goodsCount * STATION_POINTS_GOOD + passengerCount * STATION_POINTS_PASSENGER;
        updateScore();
        // Nur die Dicke zurücksetzen, nicht die Länge
        thicknessPx = 0;
        // Station verschwindet sofort, Timer für nächste Station starten
        if (stationTimeout) clearTimeout(stationTimeout);
        station = null;
        draw();
        if (stationHiddenTimeout) clearTimeout(stationHiddenTimeout);
        stationHiddenTimeout = setTimeout(spawnStation, STATION_HIDDEN_TIME);
      }
      draw();
    }

    // === Station-Logik ===
    function spawnStation() {
      if (station) return;
      let tries = 1000;
      while (tries--) {
        const x = (Math.random() * (WORLD_COLS - 1)) | 0;
        const y = (Math.random() * (WORLD_ROWS - 1)) | 0;
        // Prüfe alle 4 Zellen
        let ok = true;
        for (let dx = 0; dx < 2; dx++) {
          for (let dy = 0; dy < 2; dy++) {
            const xx = x + dx, yy = y + dy;
            if (isWall(xx, yy) || bridgeAt(xx, yy) || isDroppedItem(xx, yy) ||
                passengers.some(p => p.x === xx && p.y === yy) ||
                goods.some(g => g.x === xx && g.y === yy) ||
                train.some(t => t.x === xx && t.y === yy)) {
              ok = false;
            }
          }
        }
        if (!ok) continue;
        station = {x, y, w:2, h:2};
        draw();
        // Nach 15s verschwindet die Station
        if (stationTimeout) clearTimeout(stationTimeout);
        stationTimeout = setTimeout(() => {
          station = null;
          draw();
          // Nach 5s wieder neue Station
          if (stationHiddenTimeout) clearTimeout(stationHiddenTimeout);
          stationHiddenTimeout = setTimeout(spawnStation, STATION_HIDDEN_TIME);
        }, STATION_VISIBLE_TIME);
        break;
      }
    }
    function startStationCycle() {
      if (stationTimeout) clearTimeout(stationTimeout);
      if (stationHiddenTimeout) clearTimeout(stationHiddenTimeout);
      station = null;
      draw();
      stationHiddenTimeout = setTimeout(spawnStation, STATION_HIDDEN_TIME);
    }

    function draw(){
      // background
      ctx.fillStyle = '#0e141f'; ctx.fillRect(0,0,canvas.width,canvas.height);

      // draw yards (soft panels)
      for (let yc=0; yc<YARD_ROWS; yc++){
        for (let xc=0; xc<YARD_COLS; xc++){
          const x0 = xc*(COLS+WALL)*CELL;
          const y0 = yc*(ROWS+WALL)*CELL;
          ctx.fillStyle = '#0f1724';
          ctx.fillRect(x0, y0, COLS*CELL, ROWS*CELL);
          // coarse grid in yard
          ctx.globalAlpha = .10; ctx.strokeStyle = '#2a3750';
          for (let x=1;x<COLS;x++){ ctx.beginPath(); ctx.moveTo(x0+x*CELL,y0); ctx.lineTo(x0+x*CELL,y0+ROWS*CELL); ctx.stroke(); }
          for (let y=1;y<ROWS;y++){ ctx.beginPath(); ctx.moveTo(x0,y0+y*CELL); ctx.lineTo(x0+COLS*CELL,y0+y*CELL); ctx.stroke(); }
          ctx.globalAlpha = 1;
        }
      }

      // walls
      ctx.fillStyle = '#1b2333';
      wallSet.forEach(key => {
        const [xs,ys] = key.split(',');
        const x = parseInt(xs,10), y=parseInt(ys,10);
        if (x<0||y<0||x>=WORLD_COLS||y>=WORLD_ROWS) return; // skip outer sentinel walls
        if (bridgeAt(x,y)) return; // bridges are openings
        ctx.fillRect(x*CELL, y*CELL, CELL, CELL);
      });

      // bridges (decorate)
      bridgeMap.forEach((meta, key) => {
        const [xs,ys] = key.split(',');
        const x = parseInt(xs,10), y=parseInt(ys,10);
        // plank effect
        ctx.fillStyle = '#2a3a55';
        ctx.fillRect(x*CELL, y*CELL, CELL, CELL);
        // center stripe to hint limit
        ctx.globalAlpha = .7; ctx.fillStyle = '#3b89ff';
        ctx.fillRect(x*CELL+4, y*CELL+7, CELL-8, 2);
        ctx.globalAlpha = 1;
        // Brückenbreite visualisieren (optional):
        /* ctx.globalAlpha = 0.3;
           ctx.fillStyle = '#fff';
           ctx.fillRect(x*CELL, y*CELL, CELL, CELL);
           ctx.globalAlpha = 1; */
      });

      // pickups
      passengers.forEach(p => drawPassenger(p.x, p.y));
      goods.forEach(g => drawGoods(g.x, g.y));
      // dropped items zeichnen
      droppedItems.forEach(item => drawDroppedItem(item.x, item.y, item.type));
      // Station zeichnen
      if (station) drawStation(station.x, station.y);

      // train from tail to head so head renders on top
      for (let i=train.length-1;i>=0;i--){ drawSegment(i); }
    }

    // --- Train rendering with unlimited growth & dynamic spacing ---
    function segmentCenterPx(seg){ return { cx: seg.x*CELL + CELL/2, cy: seg.y*CELL + CELL/2 }; }

    function drawSegment(i){
      const seg = train[i];
      const {cx, cy} = segmentCenterPx(seg);
      const size = BASE_SIZE + thicknessPx; // unlimited growth
      const gap = Math.max(0, size - CELL);

      // Direction toward the neighbor closer to the head
      let ux = 0, uy = 0;
      if (i > 0){ const prev = train[i-1]; ux = prev.x - seg.x; uy = prev.y - seg.y; }
      else if (train.length > 1){ const next = train[1]; ux = seg.x - next.x; uy = seg.y - next.y; }
      if (ux !== 0 || uy !== 0){ const len = Math.hypot(ux,uy); ux/=len; uy/=len; }

      const ox = ux * (gap/2), oy = uy * (gap/2);
      if (i === 0){ drawEngineAt(cx + ox, cy + oy, size, dir); }
      else { drawCarAt(cx + ox, cy + oy, size); }
    }

    function drawEngineAt(cx,cy,size,dir){
      ctx.fillStyle = '#ffd166'; ctx.strokeStyle = '#8e6b1a';
      drawSquareCentered(cx, cy, size);
      // headlight on movement side
      const px = cx - size/2, py = cy - size/2;
      ctx.fillStyle = '#fff4b0';
      if (dir.x===1) ctx.fillRect(px+size-3, py+size/2-2, 2,4);
      if (dir.x===-1) ctx.fillRect(px+1,       py+size/2-2, 2,4);
      if (dir.y===1) ctx.fillRect(px+size/2-2, py+size-3, 4,2);
      if (dir.y===-1) ctx.fillRect(px+size/2-2, py+1,      4,2);
    }

    function drawCarAt(cx,cy,size){ ctx.fillStyle = '#6fa8ff'; ctx.strokeStyle = '#274c8f'; drawSquareCentered(cx, cy, size); }

    function drawSquareCentered(cx,cy,size){
      const s = Math.max(2, Math.round(size));
      const x = Math.round(cx - s/2);
      const y = Math.round(cy - s/2);
      ctx.fillRect(x, y, s, s);
      ctx.strokeRect(x+.5, y+.5, s-1, s-1);
    }

    function drawPassenger(x,y){
      const px=x*CELL, py=y*CELL;
      ctx.fillStyle = '#00cc44';
      ctx.fillRect(px+3, py+3, CELL-6, CELL-6);
      ctx.strokeStyle = '#006622';
      ctx.strokeRect(px+3.5, py+3.5, CELL-7, CELL-7);
    }

    function drawGoods(x,y){
      const px=x*CELL, py=y*CELL;
      ctx.fillStyle = '#cc3333';
      ctx.fillRect(px+3, py+3, CELL-6, CELL-6);
      ctx.strokeStyle = '#661111';
      ctx.strokeRect(px+3.5, py+3.5, CELL-7, CELL-7);
    }

    function drawDroppedItem(x, y, type) {
      const px = x * CELL, py = y * CELL;
      ctx.fillStyle = '#888';
      ctx.fillRect(px+3, py+3, CELL-6, CELL-6);
      ctx.strokeStyle = '#444';
      ctx.strokeRect(px+3.5, py+3.5, CELL-7, CELL-7);
    }

    function drawStation(x, y) {
      const px = x * CELL, py = y * CELL;
      ctx.save();
      // Bahnsteig mit Kante
      ctx.fillStyle = '#b0b0b0';
      ctx.fillRect(px-4, py+CELL*2-4, CELL*2+8, 8);
      ctx.fillStyle = '#888';
      ctx.fillRect(px-4, py+CELL*2+4, CELL*2+8, 3);
      // Hauskörper
      ctx.fillStyle = '#e0b97a';
      ctx.fillRect(px+6, py+10, CELL*2-12, CELL*2-16);
      // Sockel
      ctx.fillStyle = '#bfa76a';
      ctx.fillRect(px+6, py+CELL*2-12, CELL*2-12, 8);
      // Dachüberstand mit Ziegeln
      ctx.fillStyle = '#a66b2e';
      ctx.beginPath();
      ctx.moveTo(px+2, py+CELL+2);
      ctx.lineTo(px+CELL, py+2);
      ctx.lineTo(px+CELL*2-2, py+CELL+2);
      ctx.closePath();
      ctx.fill();
      // Dachschatten
      ctx.globalAlpha = 0.18;
      ctx.fillStyle = '#000';
      ctx.fillRect(px+6, py+CELL+2, CELL*2-12, 6);
      ctx.globalAlpha = 1;
      // Schornstein mit Rauch
      ctx.fillStyle = '#7a5a2e';
      ctx.fillRect(px+CELL*2-18, py+6, 8, 14);
      ctx.globalAlpha = 0.5;
      ctx.beginPath();
      ctx.arc(px+CELL*2-14, py+4, 4, 0, 2*Math.PI);
      ctx.arc(px+CELL*2-10, py+0, 3, 0, 2*Math.PI);
      ctx.fillStyle = '#ccc';
      ctx.fill();
      ctx.globalAlpha = 1;
      // Bahnhofsschild
      ctx.fillStyle = '#fff';
      ctx.fillRect(px+CELL-18, py+10, 36, 10);
      ctx.strokeStyle = '#333';
      ctx.strokeRect(px+CELL-18, py+10, 36, 10);
      ctx.fillStyle = '#1a2a4a';
      ctx.font = 'bold 8px sans-serif';
      ctx.textAlign = 'center';
      ctx.fillText('BAHNHOF', px+CELL, py+18);
      // Uhr
      ctx.save();
      ctx.beginPath();
      ctx.arc(px+CELL*2-14, py+CELL+12, 7, 0, 2*Math.PI);
      ctx.fillStyle = '#fff';
      ctx.fill();
      ctx.strokeStyle = '#333';
      ctx.lineWidth = 1.2;
      ctx.stroke();
      // Uhrzeiger
      ctx.strokeStyle = '#333';
      ctx.beginPath();
      ctx.moveTo(px+CELL*2-14, py+CELL+12);
      ctx.lineTo(px+CELL*2-14, py+CELL+7);
      ctx.moveTo(px+CELL*2-14, py+CELL+12);
      ctx.lineTo(px+CELL*2-10, py+CELL+12);
      ctx.stroke();
      ctx.restore();
      ctx.restore();
    }

    function gameOver(msg){
      dead = true; playing = false;
      statusEl.textContent = (msg || 'Crashed!') + ' Press R to restart.';
      restartBtn.classList.remove('hidden');
      draw();
      ctx.fillStyle = 'rgba(0,0,0,.35)';
      ctx.fillRect(0,0,canvas.width,canvas.height);
    }

    function togglePause(){ if (!dead){ paused = !paused; statusEl.textContent = paused ? 'Paused — press Space' : 'Use arrows/WASD. Pick up Passengers (green) to grow longer and Goods (red) to grow thicker. The world has 6 rail yards in a 2×3 grid. Bridges have width limits; exceed one and you crash.'; if (!paused) draw(); } }

    const key = (e)=>{
      const k = e.key.toLowerCase();
      const map = {
        arrowup:{x:0,y:-1}, w:{x:0,y:-1},
        arrowdown:{x:0,y:1}, s:{x:0,y:1},
        arrowleft:{x:-1,y:0}, a:{x:-1,y:0},
        arrowright:{x:1,y:0}, d:{x:1,y:0},
      };
      if (map[k]){
        // Verhindere Umkehr der Richtung
        if (!(map[k].x === -dir.x && map[k].y === -dir.y)) {
          nextDir = map[k];
        }
        e.preventDefault();
      }
      else if (k===' '){ togglePause(); e.preventDefault(); }
      else if (k==='r'){ reset(); e.preventDefault(); }
      else if (k==='f'){
        // Nur ein Good droppen, falls vorhanden
        if (!dead && playing && !paused && thicknessPx >= THICKNESS_PER_GOOD) {
          // Finde das letzte Car, das nicht Engine ist
          const lastCar = train[train.length-1];
          // Droppe ein Good an der Position des letzten Cars
          droppedItems.push({x: lastCar.x, y: lastCar.y, type: 'goods'});
          thicknessPx = Math.max(0, thicknessPx - THICKNESS_PER_GOOD);
          draw();
        }
        e.preventDefault();
      }
    };
    document.addEventListener('keydown', key, {passive:false});

    restartBtn.addEventListener('click', reset);

    reset();

    window.TrainGameYards = {
      restart: reset,
      pause: ()=>{ paused = true; },
      resume: ()=>{ paused = false; },
      setSpeed: (ms)=>{ clearInterval(tickTimer); speed = ms; tickTimer = setInterval(tick, speed); },
    };
  })();
  </script>
</body>
</html>